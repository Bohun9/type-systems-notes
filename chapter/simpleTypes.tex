\chapter{Simple Types}
\label{ch:simple-types}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simply Typed Lambda Calculus}

\newcommand\CaseTerm[3]{\texttt{case}\;#1\;\texttt{of}\;\iota_1\;x.#2\texttt{|}\iota_2\;x.#3}
\newcommand\iotaval{\iota^{\textsc{v}}}

As pure lambda calculus has empty grammar of types, we need to extend it with
some atomic values $c_b$ of type $b$, which can for example be numbers or booleans.

\begin{alignat*}{2}
  \tau & \Coloneqq \tau \to \tau \mid b
    \tag{types} \\
  e & \Coloneqq v \mid e\;e
    \tag{expressions} \\
  v & \Coloneqq x \mid \lambda x.e \mid c_b
    \tag{values}
\end{alignat*}

To derive a type of lambda abstraction, we need to first derive it for its body, remembering that current variable is bound to some type.
As lambda terms can be nested, we must store somewhere a set of assumptions about free variables occurring in a term.
This place is called environment $\Gamma$. \\

$\Gamma\vdash e : \tau$ - In context $\Gamma$ expression $e$ has type $\tau$

$\Gamma ::= \emptyset \mid \Gamma, x : \tau$

$(x:\tau) \Leftrightarrow \Gamma(x) = \tau$

$\Gamma, x:\tau \Leftrightarrow \Gamma[x \mapsto \tau]$

\begin{mathpar}
  \inferrule{ }
            {\Gamma\vdash c_b : b}

  \inferrule{(x : \tau) \in \Gamma}
            {\Gamma\vdash x : \tau}
    
  \inferrule{\Gamma, x : \tau_1 \vdash e : \tau_2}
            {\Gamma\vdash \lambda x.e : \tau_1 \to \tau_2}
  
  \inferrule{\Gamma\vdash e_1 : \tau_2 \to \tau_1 \\ \Gamma\vdash e_2 : \tau_2}
            {\Gamma\vdash e_1\;e_2 : \tau_1}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Curry-Howard Isomorphism}

Now, let's remove all terms from typing rules above, replace $\times$ with $\land$,
$+$ with $\lor$ and squint our eyes a little. What do we see? A wild natural deduction appears!

\begin{mathpar}
  \inferrule{\tau \in \Gamma}
            {\Gamma\vdash \tau}
  
  \\\\

  \inferrule{\Gamma, \tau_1 \vdash \tau_2}
            {\Gamma\vdash \tau_1 \to \tau_2}
  
  \inferrule{\Gamma\vdash \tau_2 \to \tau_1 \\ \Gamma\vdash \tau_2}
            {\Gamma\vdash \tau_1}

  \\\\
          
  \inferrule{\Gamma\vdash \tau_1 \\ \Gamma\vdash \tau_2}
            {\Gamma\vdash \tau_1 \land \tau_2}

  \inferrule{\Gamma\vdash \tau_1 \land \tau_2}
            {\Gamma\vdash \tau_i}

  \\\\

  \inferrule{\Gamma\vdash \tau_i}
            {\Gamma\vdash \tau_1 \lor \tau_2}

  \inferrule{\Gamma\vdash \tau_1 \lor \tau_2 \\ \Gamma, \tau_i \vdash \tau}
            {\Gamma\vdash \tau}
\end{mathpar}

We can also add product type (tuple) and sum type (coproduct / union) to our calculus:

\begin{alignat*}{2}
  \tau & \Coloneqq \ldots \mid \tau\times\tau \mid \tau+\tau
    \tag{types} \\
  e & \Coloneqq \ldots \mid (e,e)
      \mid \pi_1\;e \mid \pi_2\;e
      \mid \iota_1\;e \mid \iota_2\;e \mid \CaseTerm{e}{e}{e}
    \tag{expressions} \\
  v & \Coloneqq \ldots \mid \langle v, v \rangle
    \mid \iotaval_1\;v \mid \iotaval_2\;v
    \tag{values}
\end{alignat*}

Typing rules for (co)product type:

\begin{mathpar}
  \inferrule{\Gamma\vdash e_1 : \tau_1 \\ \Gamma\vdash e_2 : \tau_2}
            {\Gamma\vdash (e_1, e_2) : \tau_1\times\tau_2}

  \inferrule{\Gamma\vdash e : \tau_1\times\tau_2}
            {\Gamma\vdash \pi_i\;e : \tau_i}
            (i=1,2)

  \\\\

  \inferrule{\Gamma\vdash e : \tau_i}
            {\Gamma\vdash \iota_i\;e : \tau_1+\tau_2}
            (i=1,2)

  \inferrule{\Gamma\vdash e : \tau_1+\tau_2 \\ \Gamma, x : \tau_i \vdash e_i : \tau\ (i=1,2)}
            {\Gamma\vdash \CaseTerm{e}{e_1}{e_2} : \tau}
\end{mathpar}

Maybe we should add also typing rules for runtime constructs
$\langle v_1, v_2 \rangle$ and $\iotaval_i v$.

We then need to extend reduction semantics with the following rules:

\begin{mathpar}
  \inferrule{ }{(v_1, v_2) \rightharpoonup \langle v_1, v_2 \rangle}

  \inferrule{ }{\pi_i\;\langle v_1, v_2 \rangle \rightharpoonup v_i}

  \\\\

  \inferrule{ }{\iota_i\;v \rightharpoonup \iotaval_i\;v}
  
  \inferrule{ }{\CaseTerm{\iotaval_i\;v}{e_1}{e_2} \rightharpoonup e_i\{v/x\}}
\end{mathpar}

and evaluation context:

\begin{alignat*}{2}
  E & \Coloneqq \ldots \mid (E,e) \mid (v,E)
    \mid \pi_1\;E \mid \pi_2\;E
    \mid \iota_1\;E \mid \iota_2\;E 
    \mid \CaseTerm{E}{e_1}{e_2}
\end{alignat*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Progress and Preservation}

\begin{defin}[Type safety]
  We say that expression $e$ is \emph{type-safe}, written $\Safe{e}$
  if for any expressions $e'$ such that $e \longrightarrow^* e'$
  expression $e'$ is a value, or it makes a step, \emph{i.e.},
  there exists $e''$ such that $e' \longrightarrow e''$.
\end{defin}

XX-century technique: progress + type preservation

\begin{theorem}[Progress]
  If $\emptyset\vdash e : \tau$ then
  $e$ is a value or there exists expression~$e'$
  such that $e \longrightarrow e'$.
\end{theorem}
\begin{proof}
  Induction on the derivation of $\emptyset\vdash e : \tau$.
  Cases for unit value, variable, and lambda abstraction are trivial ---
  they are already values.
  For application case ($e_1\;e_2$), by induction hypothesis we have one
  of the following subcases: either $e_1$ makes a step,
  $e_1$ is a value and $e_2$ makes a step,
  or both $e_1$ and $e_2$ are values, $v_1$ and $v_2$ correspondingly.
  In the first two subcases the whole application makes a step.
  For the last one, we need to ensure that $v_1$ is a lambda abstraction.
  While in case of simple types this directly follows from the typing rules,
  we state this property as a separate inversion lemma (below).
\end{proof}

\begin{lemma}[Inversion for arrow type]
  If $\emptyset\vdash v : \tau_1 \to \tau_2$
  then $v = \lambda x.e$ for some $x$ and $e$,
  such that $x:\tau_1 \vdash e : \tau_2$.
\end{lemma}
\begin{proof}
  Directly by the definition of a typing relation.
  Note that the assumption about the emptiness of the typing environment
  is crucial, since variables may have an arrow type.
\end{proof}

We have defined an inversion lemma as a separate lemma in order
to make this proof technique more robust.
In case of some language extensions, like subtyping,
this lemma is not so trivial and require some additional reasoning.

\begin{theorem}
  Typing relation is preserved by a reduction.
  More precisely, if $\emptyset \vdash e : \tau$ and $e \longrightarrow e'$ then
  $\emptyset \vdash e' : \tau$.
\end{theorem}
\begin{proof}
  By induction on the typing derivation.
  Details are left as an exercise for the reader.
  In case of reductions that uses substitution ($\beta$-reduction)
  we need a substitution lemma, which in turn requires weakening lemmas.
  Both lemmas are stated below.
\end{proof}

\begin{lemma}[Weakening]
  If $\Gamma\vdash e : \tau$ then $\Gamma, x:\tau' \vdash e : \tau$
  for $x\not\in \textsf{dom}(\Gamma)$.
\end{lemma}
\begin{proof}
  By induction on the typing derivation.
  Details are left as an exercise for the reader.
\end{proof}

\begin{lemma}[Substitution]
  If $\Gamma, x:\tau_1 \vdash e : \tau_2$ and $\Gamma\vdash v : \tau_1$
  then $\Gamma\vdash e\{v/x\} : \tau_2$
\end{lemma}
\begin{proof}
  By induction on the typing derivation.
  Details are left as an exercise for the reader.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Further Reading}
