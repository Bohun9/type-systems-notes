\chapter{Syntax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grammars and Abstract Syntax Trees}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Classic Approach to Variable Binding}

\newcommand\Preterm{\mathrm{Preterm}}
\newcommand\Var{\mathrm{Var}}
\newcommand\Subst[3]{#1\{#2/#3\}}

$\Preterm$ is smallest set, such that:

\begin{itemize}
\item $\forall x \in \Var\ldotp x \in \Preterm$
\item $\forall x \in \Var\ldotp\forall t \in \Preterm\ldotp \lambda x.t \in \Preterm$
\item $\forall t_1, t_2 \in \Preterm\ldotp t_1\;t_2 \in \Preterm$
\end{itemize}

Probem: some distinct preterms such as $\lambda x \ldotp x$ and $\lambda y \ldotp y$
differ in bound variable names, but represent the same computation.

Solution: $\alpha$-equivalence relation - terms that differ only in the
names of bound variables will belong to the same equivalence class.

But first, substitution on preterms (partial function):

\[
  \Subst{\cdot}{\cdot}{\cdot} \colon
  \Preterm \times \Var \times \Preterm \to \Preterm
\]
\begin{eqnarray*}
  \Subst{x}{t}{x}          & = & t \\
  \Subst{y}{t}{x}          & = & y, \text{if } x \ne y \\
  \Subst{(t_1\;t_2)}{t}{x} & = & (\Subst{t_1}{t}{x})\;(\Subst{t_1}{t}{x}) \\
  \Subst{(\lambda x.t')}{t}{x} & = & \lambda x.t' \\
  \Subst{(\lambda y.t')}{t}{x} & = & \lambda y.\Subst{t'}{t}{x}, \text{if } x \ne y \land y \not\in FV(t)
\end{eqnarray*}

$\alpha$-equivalence relation:

\newcommand\Aeq{\equiv_\alpha}

\begin{mathpar}
  \inferrule{ }
            {t \Aeq t}

  \inferrule{t_1 \Aeq t_2 \\ t_2 \Aeq t_3}
            {t_1 \Aeq t_3}

  \inferrule{t_2 \Aeq t_1}
            {t_1 \Aeq t_2}

  \inferrule{ }
            {x \Aeq x}

  \inferrule{t_1 \Aeq t_1' \\ t_2 \Aeq t_2'}
            {t_1\;t_2 \Aeq t_1'\;t_2'}

  \inferrule{t_1 \Aeq t_2}
            {\lambda x.t_1 \Aeq \lambda x.t_2}

  \inferrule{y \not\in FV(t)}
            {\lambda x.t \Aeq \lambda y.\Subst{t}{y}{x}}

\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variable Binding via Indexed Families of Sets}

% Indexed family of sets of terms
\newcommand\ITerm[1]{\mathrm{Term}_{#1}}
% Variable constructor
\newcommand\ITVar[1]{\ulcorner #1 \urcorner}
% Successor (constructor of X+1)$
\newcommand\ITSucc{\mathsf{s}}
% Extending set by one element
\newcommand\ITInc[1]{#1\!+\!1}

While the treatment of variable binding in the previous section is close
to intuitive meaning, the construction is bit involved and not very convenient
when we work with proof assistants, like Coq.
In this section we present another approach that do not require
any quotient sets.
In order to avoid quotient sets and $\alpha$-equivalence our representation
should be \emph{nameless}, \emph{i.e.}, bound variables should not have
any names.

One well-known example of a nameless approach is a representation based on
de Bruijn indices~\citep{deBruijn72}.
The idea is to uniquely represent a bound variable by a number (index),
that describes how many other binders we should skip to find
a corresponding binder.
For instance, term $\lambda x.\lambda y.x\;y$ will be
represented as $\lambda\lambda 1\;0$.
Two things should be noted here.
First, the lambda abstraction does not store any name,
because the representation is nameless and
bound variables are matched with their binders not by name,
but by counting.
Secondly, it is not clear how to represent free variables.
Basically, there are two approaches.
\begin{itemize}
\item We can treat indices as free, when they are too big to be bound.
  As this seems to be natural, it has some drawbacks.
  Usually, we identify free variables by their names.
  These names have no additional structure,
  but have some meaning to the programmer.
  In this plain de Bruijn representation free variables
  have no names and we impose some order on then (order on natural numbers)
  that have no counterpart on our intuitive understanding of variables.
\item We can have separate notion of free variables (represented by names)
  and bound variables (represented by indices).
  Such an approach is called
  \emph{locally nameless}~\citep{AydemirCPPW08,Chargueraud12}
  and was successfully applied to some larger Coq or Agda formalizations.
  However, in this representation we still have to deal with indices
  too big to be bound, and in order to do so,
  we work with \emph{locally closed terms}, \emph{i.e.},
  terms that do not have such a too big indices.
  Such an additional ``locally closed'' relation introduces some
  unnecessary clutter into a formalization.
\end{itemize}

In this section we present another nameless approach,
that combines advantages of both mentioned approaches.
We start with the observation that in most cases, when we work
with open terms, there is a some kind of scope or an environment
that provides a meaning of free variables.
In such cases we allow only terms where all free variables
are in this scope.
For instance, evaluation function $\texttt{eval}\;\rho\;e$
accepts only expressions where for each free variable~$x$,
its meaning $\rho(x)$ is defined in the environment,
or typing relation $\Gamma\vdash e\;:\:\tau$
(see \autoref{ch:simple-types})
requires that all free variables have assigned type in~$\Gamma$.
Another extreme example is when we work with closed terms:
their scope is empty and no free variables are allowed.

With this intuition in mind, we can construct a set~$\ITerm{X}$,
for each set~$X$, that will be called a~set of
\emph{potentially free} variables.
We can think about this set of potentially free variables
as a scope of the term.
For example $\ITerm{\varnothing}$ contains all closed terms
(without any free variables),
while $\ITerm{\Var}$ is a set (isomorphic to a set)
of terms from the previous section.

Formally $\ITerm{X}$ is smallest set, such that:

\begin{itemize}
\item $\forall x \in X\ldotp \ITVar{x} \in \ITerm{X}$
\item $\forall t \in \ITerm{X+1}\ldotp \lambda t \in \ITerm{X}$
\item $\forall t_1, t_2 \in \ITerm{X}\ldotp t_1\;t_2 \in \ITerm{X}$
\end{itemize}

$\ITInc{X}$ is isomorphic to \texttt{Maybe} or \texttt{option}
and is defined as:

\begin{itemize}
\item $0 \in \ITInc{X}$
\item $\forall x \in X\ldotp \ITSucc\;x \in \ITInc{X}$
\end{itemize}

We should note that we changed $\lambda x.t$ to simply $\lambda t$.
The role of $x$ now belongs to 0, which may be present in $t \in \ITerm{X+1}$.
For example term $\lambda x.\lambda y. xy$
would be written as $\lambda\lambda \ITSucc\;0\;0 = \lambda\lambda 1\;0$.

With the removal of names for bound variables we don't run into the same problems as before.
The only thing left to do is to define substitution
\[
	\cdot\{\cdot\}:
  \ITerm{X+1} \times \ITerm{X} \to \ITerm{X}
\]

and to do that we need to define:

$^* \colon (X \to \ITerm{Y}) \to \ITerm{X} \to \ITerm{Y}$ (also known as \texttt{bind})

\begin{eqnarray*}
  f^*\ITVar{x}   & = & f\;x \\
  f^*(\lambda t) & = & \lambda (f^{\Uparrow*} \; t) \\
  f^*(t_1\;t_2)  & = & (f^* \; t_1) \; (f^* \; t_2)
\end{eqnarray*}

$^\Uparrow \colon (X \to \ITerm{Y}) \to \ITInc{X} \to \ITerm{\ITInc{Y}}$

\begin{eqnarray*}
  f^\Uparrow 0 & = & \ITVar{0} \\
  f^\Uparrow (\ITSucc \; x) & = & \ITSucc^\dagger\;(f\;x) \\
\end{eqnarray*}

$^\dagger \colon (X \to Y) \to \ITerm{X} \to \ITerm{Y}$ (also known as \texttt{fmap})

\begin{eqnarray*}
  f^\dagger\ITVar{x}   & = & \ITVar{f\;x} \\
  f^\dagger(\lambda t) & = & \lambda(f^{\uparrow\dagger}\;t) \\
  f^\dagger(t_1\;t_2)  & = & (f^\dagger\;t_1)\;(f^\dagger\;t_2)
\end{eqnarray*}

$\uparrow \colon (X \to Y) \to \ITInc{X} \to \ITInc{Y}$
  (also known as \texttt{fmap} but on \texttt{Maybe})

\begin{eqnarray*}
  f^\uparrow 0            & = & 0 \\
  f^\uparrow (\ITSucc\;x) & = & \ITSucc\;(f \; x)
\end{eqnarray*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Further Reading}
