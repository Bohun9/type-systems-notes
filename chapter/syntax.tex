\chapter{Syntax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Grammars and Abstract Syntax Trees}

Throughout the remainder of these lecture notes, we will specify the abstract
syntax of various elements of the considered calculi in the form of a grammar,
such as the following grammar of the plain $\lambda$-calculus.
\begin{alignat*}{2}
  &x, y, z, \dots \span\span \tag{variables} \\
  &t &&\Coloneqq x \mid \lambda x\ldotp t \mid t\;t \tag{terms}
\end{alignat*}
There are only two syntactic categories in this grammar: variables
($x, y, z, \dots$) and terms ($t$). A term can be a variable,
a $\lambda$-abstraction, or an application of one term to another.
As this grammar is supposed to represent the \emph{abstract syntax trees},
rather than the strings of any particular concrete syntax, we do not consider
parentheses, priorities or associativity. When writing such
terms down, we will use various common conventions, \emph{e.g.}, the
body of a $\lambda$-abstraction extends as far right as possible, and
application is left-associative. This allows us to write
$\lambda x\ldotp t_1\;t_2$ for $\lambda x\ldotp (t_1\;t_2)$
and $t_1\;t_2\;t_3$ for $(t_1\;t_2)\;t_3$.

Note that the presented grammar says nothing about how the variables are
represented. It is convenient to abstract away from such
inconsequential details on paper, and make various assumptions about which
variables can be safely treated as distinct. However, to ground such
intuitions and to give us a good foundation for formal reasoning with
the use of a proof assistant, the following two sections describe
two concrete approaches to variables and variable binding.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Classic Approach to Variable Binding}

\newcommand\Preterm{\syncatset{Preterm}}
\newcommand\Term{\syncatset{Term}}
\newcommand\Var{\syncatset{Var}}
\newcommand\FVars[1]{\mathrm{fv}(#1)}
\newcommand\Subst[3]{#1\{#2/#3\}}
\newcommand\Aeq{\equiv_\alpha}

Let $\Var$ be some infinite set of variable names.
Then we can define $\Preterm$ as the smallest set such that
\begin{itemize}
\item $\forall x \in \Var\ldotp x \in \Preterm$,
\item $\forall x \in \Var\ldotp\forall t \in \Preterm\ldotp \lambda x\ldotp t \in \Preterm$,
\item $\forall t_1, t_2 \in \Preterm\ldotp t_1\;t_2 \in \Preterm$.
\end{itemize}
At first glance, this definition appears similar to the grammar of the
$\lambda$-calculus.
However, if $x \neq y$, then $\lambda x\ldotp x$ and $\lambda y\ldotp y$ are
not equal, even though they differ only in the choice of bound variable names,
which does not affect the represented computation. We will define an
equivalence relation, traditionally known as $\alpha$-equivalence, to identify
such terms.

\begin{figure}[t!!]
\[
  \Subst{\cdot}{\cdot}{\cdot} \colon
  \Preterm \times \Var \times \Preterm \rightharpoonup \Preterm
\]
\begin{eqnarray*}
  \Subst{x}{t}{x}          & = & t \\
  \Subst{y}{t}{x}          & = & y, \text{ if } x \ne y \\
  \Subst{(t_1\;t_2)}{t}{x} & = & (\Subst{t_1}{t}{x})\;(\Subst{t_1}{t}{x}) \\
  \Subst{(\lambda x\ldotp t')}{t}{x} & = & \lambda x\ldotp t' \\
  \Subst{(\lambda y\ldotp t')}{t}{x} & = & \lambda y\ldotp \Subst{t'}{t}{x}, \text{ if } x \ne y \land y \not\in \FVars{t}
\end{eqnarray*}
\caption{The substitution operation for preterms.}
\label{fig:syntax_preterm_subst}
\end{figure}

We are going to need a way to rename the variables occurring in preterms.
More generally, we can define the substitution of entire preterms for
variables as a partial function, as shown in
\autoref{fig:syntax_preterm_subst}.
The case for $\lambda$-abstraction is tricky, since we need to be careful
to avoid \emph{variable capture}.
For example, in the substitution $\Subst{(\lambda y\ldotp x)}{y}{x}$,
we cannot simply substitute under the binder. If we did, we would get
$\lambda y \ldotp y$, which is clearly incorrect---the free variable $y$ was
captured by the abstraction!
Thus, we define $\Subst{(\lambda y\ldotp t')}{t}{x}$ only when $y$ is not in
the set of free variables of $t$, denoted as $\FVars{t}$. Despite being
partial, this notion of substitution is sufficient for the purpose of defining
$\alpha$-equivalence.

\begin{figure}[t!!]
\begin{mathpar}
  \inferrule{ }
            {t \Aeq t}

  \inferrule{t_2 \Aeq t_1}
            {t_1 \Aeq t_2}

  \inferrule{t_1 \Aeq t_2 \\ t_2 \Aeq t_3}
            {t_1 \Aeq t_3}

  \inferrule{ }
            {x \Aeq x}

  \inferrule{t_1 \Aeq t_1' \\ t_2 \Aeq t_2'}
            {t_1\;t_2 \Aeq t_1'\;t_2'}

  \inferrule{t_1 \Aeq t_2}
            {\lambda x.t_1 \Aeq \lambda x.t_2}

  \inferrule{y \not\in \FVars{t}}
            {\lambda x.t \Aeq \lambda y.\Subst{t}{y}{x}}

\end{mathpar}
\caption{The $\alpha$-equivalence relation.}
\label{fig:syntax_alpha_equiv}
\end{figure}

The $\alpha$-equivalence relation is defined in
\autoref{fig:syntax_alpha_equiv}.
It has the three usual rules that make it an equivalence relation:
reflexivity, symmetry and transitivity. Additionally, the relation
is a congruence: it is compatible with the preterm constructors
thanks to the three structural rules.\footnote{
  The rule for variables is somewhat redundant, as it is just a special case
  of reflexivity.
} Finally, the last presented rule allows the variable bound by a
$\lambda$-abstraction to be renamed, as long as it does not result in the
capture of any of the free variable in its body.

We can now define the set of terms as the quotient set
\[ \Term = \Preterm / {\Aeq}, \]
which is the set of all equivalence classes of $\Aeq$. It is customary to
simply write $t$ in place of $[t]_{\Aeq}$, and only consider terms up to
$\alpha$-equivalence. Substitution for terms can be defined as a total
function, as capture can be avoided by the use of variable renaming.
We can lift the substitution operation for preterms to terms by using it on the
representatives of the $\alpha$-equivalence classes. Proving that this
definition is well-behaved is left as an exercise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variable Binding via Indexed Families of Sets}

% Indexed family of sets of terms
\newcommand\ITerm[1]{\syncatset{Term}_{#1}}
% Variable constructor
\newcommand\ITVar[1]{\ulcorner\! #1 \!\urcorner}
% Successor (constructor of X+1)$
\newcommand\ITSucc{\mathsf{s}}
% Extending set by one element
\newcommand\ITInc[1]{#1\!+\!1}

While the treatment of variable binding in the previous section is close
to intuitive meaning, the construction is bit involved and not very convenient
when we work with proof assistants, like Coq.
In this section we present another approach that do not require
any quotient sets.
In order to avoid quotient sets and $\alpha$-equivalence our representation
should be \emph{nameless}, \emph{i.e.}, bound variables should not have
any names.

One well-known example of a nameless approach is a representation based on
de Bruijn indices~\citep{deBruijn72}.
The idea is to uniquely represent a bound variable by a number (index),
that describes how many other binders we should skip to find
a corresponding binder.
For instance, term $\lambda x.\lambda y.x\;y$ will be
represented as $\lambda\lambda 1\;0$.
Two things should be noted here.
First, the lambda abstraction does not store any name,
because the representation is nameless and
bound variables are matched with their binders not by name,
but by counting.
Secondly, it is not clear how to represent free variables.
Basically, there are two approaches.
\begin{itemize}
\item We can treat indices as free, when they are too big to be bound.
  As this seems to be natural, it has some drawbacks.
  Usually, we identify free variables by their names.
  These names have no additional structure,
  but have some meaning to the programmer.
  In this plain de Bruijn representation free variables
  have no names and we impose some order on then (order on natural numbers)
  that have no counterpart on our intuitive understanding of variables.
\item We can have separate notion of free variables (represented by names)
  and bound variables (represented by indices).
  Such an approach is called
  \emph{locally nameless}~\citep{AydemirCPPW08,Chargueraud12}
  and was successfully applied to some larger Coq or Agda formalizations.
  However, in this representation we still have to deal with indices
  too big to be bound, and in order to do so,
  we work with \emph{locally closed terms}, \emph{i.e.},
  terms that do not have such a too big indices.
  Such an additional ``locally closed'' relation introduces some
  unnecessary clutter into a formalization.
\end{itemize}

In this section we present another nameless approach,
that combines advantages of both mentioned approaches.
We start with the observation that in most cases, when we work
with open terms, there is a some kind of scope or an environment
that provides a meaning of free variables.
In such cases we allow only terms where all free variables
are in this scope.
For instance, evaluation function $\texttt{eval}\;\rho\;e$
accepts only expressions where for each free variable~$x$,
its meaning $\rho(x)$ is defined in the environment,
or typing relation $\Gamma\vdash e\;:\:\tau$
(see \autoref{ch:simple-types})
requires that all free variables have assigned type in~$\Gamma$.
Another extreme example is when we work with closed terms:
their scope is empty and no free variables are allowed.

With this intuition in mind, we can construct a set~$\ITerm{X}$,
for each set~$X$, that will be called a~set of
\emph{potentially free} variables.
We can think about this set of potentially free variables
as a scope of the term.
For example $\ITerm{\varnothing}$ contains all closed terms
(without any free variables),
while $\ITerm{\Var}$ is a set (isomorphic to a set)
of terms from the previous section.

We will define $\ITerm{X}$ inductively.
Before going into details, let us see how we can represent a variable binding.
Obviously, we can find some lambda-abstractions in $\ITerm{X}$.
Because we are aiming for a nameless representation,
these lambda-abstraction have the form $\lambda t$,
where the variable bound by a lambda has no name.
What is a set of potentially free variables of the body~$t$?
It is a set~$X$ extended with this one extra variable bound by the lambda.
We will write $\ITInc{X}$ for such a set,
and $0$ for this new element.
But $X$ may be an arbitrary set, in particular, it can already contain element~$0$.
Therefore, in the set $\ITInc{X}$
we wrap all elements of $X$ around the constructor $\ITSucc$
in order to distinguish them from $0$.
Formally, $\ITInc{X}$ has the following inductive definition.

\begin{defin}
  For any set $X$ we define $\ITInc{X}$ as the smallest set, such that:
  \begin{thmenumerate}
  \item $0 \in \ITInc{X}$,
  \item for each $x\in X$ we have $\ITSucc\;x \in X$.
  \end{thmenumerate}
\end{defin}

Note that $\ITInc{X}$ is isomorphic to \texttt{Maybe} or \texttt{option}
known from functional programming.
Now, we can formally define set of terms~$\ITerm{X}$.

\begin{defin}
  For any set $X$ we define $\ITerm{X}$ as the smallest set, such that:
  \begin{thmenumerate}
  \item for each $x \in X$ a term $\ITVar{x}$ that represents a variable
    is a valid term ($\ITVar{x} \in \ITerm{X}$);
  \item for each $t \in \ITerm{\ITInc{X}}$
    a lambda-abstraction $\lambda t$ is a valid term ($\lambda t \in \ITerm{X}$);
  \item for each $t_1,t_2 \in \ITerm{X}$ an application $t_1\;t_2$
    is a valid term ($t_1\;t_2 \in \ITerm{X}$).
  \end{thmenumerate}
\end{defin}

Since a set of potentially free variables may be an arbitrary set,
in particular, it can be also a set of terms (we may have $\ITerm{\ITerm{X}}$).
In order to avoid some notational ambiguity, we explicitly wrap variables around
a constructor $\ITVar{x}$.

An interesting side note is a connection of presented term representation with
de Bruijn indices.
If we treat $\ITSucc\;n$ as a successor of $n$, and write $\ITSucc\;0$ as $1$,
$\ITSucc(\ITSucc\;0)$ as $2$, \emph{etc.},
then for closed terms we obtain exactly de Bruijn indices!
For example term $\lambda x.\lambda y. x\;y$
would be written as $\lambda\lambda \ITVar{1}\;\ITVar{0}$.

With the removal of names for bound variables we don't run into the same problems as before.
The only thing left to do is to define substitution
\[
	\cdot\{\cdot\}:
  \ITerm{X+1} \times \ITerm{X} \to \ITerm{X}
\]

and to do that we need to define:

$^* \colon (X \to \ITerm{Y}) \to \ITerm{X} \to \ITerm{Y}$ (also known as \texttt{bind})

\begin{eqnarray*}
  f^*\ITVar{x}   & = & f\;x \\
  f^*(\lambda t) & = & \lambda (f^{\Uparrow*} \; t) \\
  f^*(t_1\;t_2)  & = & (f^* \; t_1) \; (f^* \; t_2)
\end{eqnarray*}

$^\Uparrow \colon (X \to \ITerm{Y}) \to \ITInc{X} \to \ITerm{\ITInc{Y}}$

\begin{eqnarray*}
  f^\Uparrow 0 & = & \ITVar{0} \\
  f^\Uparrow (\ITSucc \; x) & = & \ITSucc^\dagger\;(f\;x) \\
\end{eqnarray*}

$^\dagger \colon (X \to Y) \to \ITerm{X} \to \ITerm{Y}$ (also known as \texttt{fmap})

\begin{eqnarray*}
  f^\dagger\ITVar{x}   & = & \ITVar{f\;x} \\
  f^\dagger(\lambda t) & = & \lambda(f^{\uparrow\dagger}\;t) \\
  f^\dagger(t_1\;t_2)  & = & (f^\dagger\;t_1)\;(f^\dagger\;t_2)
\end{eqnarray*}

$\uparrow \colon (X \to Y) \to \ITInc{X} \to \ITInc{Y}$
  (also known as \texttt{fmap} but on \texttt{Maybe})

\begin{eqnarray*}
  f^\uparrow 0            & = & 0 \\
  f^\uparrow (\ITSucc\;x) & = & \ITSucc\;(f \; x)
\end{eqnarray*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Further Reading}
